{
  
    
        "post0": {
            "title": "Proving Proximal Gradient Method's Convergence Rate and a Code Demonstration",
            "content": "Proximal Gradient Descent . A proximal algorithm is an algorithm for solving a convex optimization problem that uses the proximal operators of the objective terms. It is called such since it consists of a gradient step followed by a proximal mapping. There are three main benefits to the application of proximal algorithms: . They work under extremely general conditions, including cases where the functions are nonsmooth and extended real-valued | | They can be fast, since there can be simple proximal operators for functions that are otherwise challenging to handle in an optimization problem | | They are amenable to distributed optimization, so they can be used to solve very large scale problems | | . The proximal operator is defined as $$ prox_f(x) = argmin left { f(u) + frac{1}{2} left | u-x right |^2: u in mathbb{R}^n right }, forall x in mathbb{R}^n $$ with the goal being to $$minimize left { f(u) + h(u): u in mathbb{R}^n right }$$ where h is a proper lower semi-continuous function and f is a smooth convex function on dom(h). . Some important assumptions before we begin: . We assume that f has L-Lipschitz continuous gradient, i.e., $$ left | bigtriangledown f(x) - bigtriangledown f(y) right | leq L left | x-y right |, forall x, y in dom(h)$$ and hence for every $x, y in dom(h)$, $$ f(x) leq l_f(x; y) + frac{L}{2} left | x-y right |^2$$ where $l_f(x; y) := f(y) + left langle bigtriangledown f(y), x-y right rangle$. . Recal that PGM with a constant prox stepsize is recursive in nature and iterates according to : $$x_{k+1}=prox_{ lambda h}(x_k- lambda nabla f(x_k)).$$ . Let&#39;s get started! . First, we will derive a single iteration of PGM and prove that it is strong convex. . $$ x_{k+1} = argmin left { h(u) + frac{1}{2} left | u-(x_k- bigtriangledown f(x_k)) right |^2 right }$$ . $$ x_{k+1} = argmin left { f(x_k) + left langle bigtriangledown f(x_k), u-x_k right rangle +h(u) + frac{1}{2} left | x-x_k right |^2 right }$$ . $$x_{k+1}= argmin left { ell_f(u;x_k)+h(u) + frac{1}{2 lambda}||u-x_k||^2 right }, $$ . And proving strong convexity $ left langle bigtriangledown h(u) - bigtriangledown h(x), u - x right rangle geq lambda left | u-x right |^{2}$: . $$ left langle prox_{ lambda h}(u) - prox_{ lambda h}(x), (u- frac{1}{ lambda} bigtriangledown h(u)) -(x- frac{1}{ lambda} bigtriangledown h(x)) right rangle geq left | prox_{ lambda h}(u)-prox_{ lambda h}(x) right |^{2} $$ . $$ left langle (u - frac{1}{ lambda} bigtriangledown h(u)) - (x - frac{1}{ lambda} bigtriangledown h(x)), (u- frac{1}{ lambda} bigtriangledown h(u)) -(x- frac{1}{ lambda} bigtriangledown h(x)) right rangle geq left | (u - frac{1}{ lambda} bigtriangledown h(u)) - (x - frac{1}{ lambda} bigtriangledown h(x)) right |^{2} $$ . Using the definition of $x_{k+1}$ and the strong convexity, we obtain upon rearranging terms that: . $$ h(x_{k+1}) leq h(x) + left langle - bigtriangledown f(u), x^{k+1}-x right rangle + frac{1}{2} left | u-x right |^2 - frac{1}{2} left | u-x^{k+1} right |^2 - frac{1}{2} left | x^{k+1}-x right |^2 $$ . Due to the Lipschitz continuity: $$ f(x_{k+1}) leq f(u) + left langle - bigtriangledown f(u), u-x^{k+1} right rangle + frac{1}{2} left | u-x_{k+1} right |^2 $$ . Adding the two: $$ f(x_{k+1}) + h(x_{k+1}) leq f(u) + h(x) + left langle bigtriangledown f(u), u-x right rangle - frac{1}{2} left | x_{k+1}-x right |^2 + frac{1}{2} left | u-x right |^2 $$ . Using definition for $ ell_f(u;x_k)$ $$ ell_f(u;x_k)+h(u) + frac{1}{2}||u-x_k||^2 geq ell_f(x_{k+1};x_k)+h(x_{k+1})+ frac{1}{2}||x_{k+1}-x_k||^2 + frac{1}{2}||u-x_{k+1}||^2$$ . Similarly for any x in int(dom(f)): $$ f(x_*) leq f(x) + left langle bigtriangledown f(x), x_*-x right rangle + frac{1}{2 lambda} left | x_*-x right |^2 $$ It holds that $$ (f+h)(x)-(f+h)(x_*) geq frac{1}{2 lambda} left | x-x_* right |^2 $$ . Consider $$ g(u) = f(x_{k+1})+ left langle bigtriangledown f(x_{k+1}), u-x_{k+1} right rangle + g(u)+ frac{1}{2 lambda} left | u-x_{k+1} right |^2$$ . $ x_* = argmin_g(u) $ $$ g(x)-g(x_*) geq frac{1}{2 lambda} left | x-x_* right |^2 $$ . Since $$ g(x_*) = f(x_{k+1}) + left langle bigtriangledown f(x_{k+1}),x_*-x_{k+1} right rangle + frac{1}{2 lambda} left | x_*-x_{k+1} right |^2 + h(x_*) $$ $$ geq f(x_*)+h(x_*) = (f+h)(x_*) $$ . This implies that $$ h(x_{k+1})-(f+h)(x_*) geq frac{1}{2 lambda} left | x_{k+1}-x_* right |^2 $$ . Plugging for g(u) into above inequality . $$ f(x_{k+1}) + left langle bigtriangledown f(x_{k+1}), x-x_{k+1} right rangle + h(x)+ frac{1}{2 lambda} left | x-x_{k+1} right |^2 -(f+h)(x_*) geq frac{1}{2 lambda} left | x-x_* right |^2$$ . Which is equal to . $$ (f+h)(x_{k+1})-(f+h)(x_*) geq frac{1}{2 lambda} left | x_{k+1}-x_* right |^2 - frac{1}{2 lambda} left | x-x_{k+1} right |^2 +f(x_{k+1}) + ell_f(x;x_{k+1}) $$ . $$(f+h)(x_*)+ frac{1}{2 lambda}||x_k-x_*||^2 geq (f+h)(x_{k+1})+h(x_{k+1})+ frac{1}{2 lambda}||x_{k+1}-x_*||^2$$ . Using $$ frac{1}{2 lambda}((f+h)(x_*)-(f+h)(x_{k+1})) geq left | x_*-x_{k+1} right |^2 - left | x_*-x_k right |^2 + frac{1}{2 lambda} ell_f(x_*,x_k)$$ . $$ frac{1}{2 lambda}((f+h)(x_*)-(f+h)(x_{k+1})) geq left | x_*-x_{k+1} right |^2 - left | x_*-x_k right |^2 $$ . Sum over all n from 0 to k to obtain: $$ frac{1}{2 lambda} sum_{}^{k}(f+h)(x_*)-(f+h)(x_{k+1}) geq left | x_*-x_k right |^2- left | x_*-x_0 right |^2 $$ . Thus $$ sum_{}^{k}((f+h)(x_{k+1})-(f+h)(x_*)) leq frac{1}{2 lambda} left | x_*-x_0 right |^2- frac{1}{2 lambda} left | x_*-x_k right |^2 leq frac{1}{2 lambda} left | x_*-x_0 right |^2 $$ . Given the monotonicity of $(f+h)(x_n)$ for $n geq 0$ $$ k((f+h)(x_k)-(f+h)(x_*)) leq sum_{}^{k}((f+h)(x_{k+1})-(f+h)(x_*)) leq frac{1}{2 lambda} left | x_*-x_0 right |^2 $$ . Thus $$ sum_{i=1}^k (f+h)(x_i)-k(f+h)(x_*) leq frac{||x_0-x_*||^2}{2 lambda} $$ . Proving PGM has the descent property: . $$(f+h)(x_k) geq (f+h)(x_{k+1}), forall k geq 0 $$ . $$ frac{1}{2 lambda}((f+h)(x_*)-(f+h)(x_{k+1})) geq left | x_*-x_{k+1} right |^2 - left | x_*-x_k right |^2 + frac{1}{2 lambda} ell_f(x_*,x_k)$$ . Along with the relationship: $$ left | x_{k+1} -x_* right | leq left | x_k-x_* right |$$ . It follows that: $$ (f+h)(x_*)-(f+h)(x_{k+1}) leq (f+h)(x_*)-(f+h)(x_{k}) leq 0$$ . Thus for all k $ geq 0$ $$(f+h)(x_{k+1}) leq (f+h)(x_{k}) $$ . Finally, given the above: $$ k((f+h)(x_k)-(f+h)(x_*)) leq sum_{}^{k}((f+h)(x_{k+1})-(f+h)(x_*)) leq frac{1}{2 lambda} left | x_0-x_* right |^2 $$ Consequently $$ (f+h)(x_i)-(f+h)(x_*) leq frac{1}{k2 lambda}||x_0-x_*||^2 $$ . Hence we obtain the $O( frac{1}{k})$ convergence rate . . Code Example . Here we will employ proximal gradient descent with stochastic schemes. In general, when the loss function we are trying to minimize can be wwritten in the form $ sum_{i=1}^{m}g_i( theta )$ where each $g_i( theta)$ is the loss sample at i, and the training time is long, then stochastic schemes should be considered. We will optimize $$f( theta) = underset{ theta in mathbb{R}^d}{min} frac{1}{m} sum_{i=1}^{m} left [ log(1+exp(x_i theta)) -y_ix_i theta right ] + lambda left | theta right |_1$$ We decompose $f( theta)$ into a convex and differentiable function g and a convex but not differentiable function h: $$ g( theta) = frac{1}{m} sum_{i=1}^{m}log(1+exp(x_i theta)) $$ $$ h( theta) = frac{1}{m} sum_{i=1}^{m} -y_ix_i theta + lambda left | theta right |_1$$ . The data we are using is from the classic MNIST machine learning dataset. There are two classes, 0 and 1, and we have a total of 14,780 images; a training set of 12,665 and a test set of 2,115. Each image is 28x28. Each image is vectorized and stacked to form a training and test matrix, with the label appended to the last column of each matrix. Thus, our classifier will learn $ theta$ on the train set to predict the labels for the test set. . import numpy as np from sklearn.metrics import accuracy_score . x_train = train[:, :-1] y_train = train[:, -1 :] x_test = test[:, :-1] y_test = test[:, -1 :] x = x_train y = y_train . def predict_labels(X, weights): return 1/(1+np.exp(-X.dot(weights))) def soft_threshold(x,t): pos = np.maximum(x - t, 0) neg = np.minimum(x + t, 0) return pos+neg def log_loss(X, theta): return np.sum(np.log(1 + np.exp(X.dot(theta)))) / X.shape[0] def h(X, y, lam=10, lr=0.01): return (1/len(X))*(-y.T.dot(X)) + lam*lr def evaluate_gradient(X, theta, y=None): return np.sum((X*np.exp(X.dot(theta))) / (1 + np.exp(X.dot(theta))), axis=0)/m . n = 100 lam = 10 lr= 0.01 max_iters=1000 tol= 1e-3 N, D = x.shape theta_current = np.zeros(shape=(D, 1)) losses = [log_loss(x, theta_current)] thetas = [theta_current] iterations = 1 while (loss &gt; tol) or (iterations &gt; max_iters): theta_current = thetas[-1] # Stochastic number_of_rows = x.shape[0] random_indices = np.random.choice(number_of_rows, size=n, replace=False) x_temp, y_temp = x[random_indices, :], y[random_indices, :] for it in range(n): # Proximal GD grad = evaluate_gradient(x_temp, theta_current).reshape(-1,1) theta_new_grad = theta_current - (lr * grad) theta_new = soft_threshold(theta_new_grad, h(x_temp, y_temp)) theta_current = theta_new loss = log_loss(x, theta_current) losses.append(loss) thetas.append(theta_current) iterations += 1 . n = 100 lam = 10 lr= 0.01 max_iters=1000 tol= 1e-5 N, D = x.shape theta_current = np.zeros(shape=(D, 1)) loss_1 = log_loss(x, theta_current) losses = [loss_1] thetas = [theta_current] iterations = 1 #while losses[-1] &gt; tol: for i in range(200): theta_current = thetas[-1] grad = evaluate_gradient(x, theta_current).reshape(-1,1) theta_new_grad = theta_current - (lr * grad) theta_new = soft_threshold(theta_new_grad, h(x, y).T) theta_current = theta_new loss = log_loss(x, theta_current) losses.append(loss) thetas.append(theta_current) #iterations += 1 . predict_labels(x, thetas[-1]) accuracy_score(y_test, predict_labels(x_test, thetas[-1])) . Overall, this stochastic implementation achieves an accuracy of 93.76 on the training set. .",
            "url": "https://jackhmiller.github.io/My-DS-Blog/fastpages/jupyter/2020/08/05/PGD.html",
            "relUrl": "/fastpages/jupyter/2020/08/05/PGD.html",
            "date": " • Aug 5, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Alternating Method of Multipliers- Theory and Industry Example Application",
            "content": "In this blog post we will solve the following optimization problem using the scaled form of alternating direction method of multipliers (ADMM). . $$ min frac{1}{2} left | Ax-b right |_{2}^{2} + lambda_1 left | x right |_1 + frac{ lambda_2}{2} left | x right |_{2}^{2}min frac{1}{2} left | Ax-b right |_{2}^{2} + lambda_1 left | x right |_1 + frac{ lambda_2}{2} left | x right |_{2}^{2}$$ . Background on ADMM . The alternating direction method of multipliers (ADMM) is an algorithm that solves convex optimization problems by breaking them into smaller pieces, each of which are then easier to handle. Namely, it is intended to blend the decomposability of dual ascent with the superior convergence properties of the method of multipliers. The original paper can be found here: https://stanford.edu/~boyd/papers/pdf/admm_distr_stats.pdf. . ADMM received lots of attention a few years ago due to the tremendous proliferation and subsequentdemand from large-scale and data-distributed machine learning applications. ADMM a fairly simple computational method for optimization proposed in 1970s. It stemmed from the augmented Lagrangian method (also known as the method of multipliers) dating back to late 1960s. The theoretical aspects of ADMM have been studied since the 1980s, and its global convergence was established in the literature (Gabay, 1983; Glowinski &amp; Tallec, 1989;Eckstein &amp; Bertsekas, 1992). As reviewed in the comprehensive paper (Boyd et al., 2010), with the ability of dealing with objective functions separately and synchronously , ADMM turned out to be a natural fit in the field of large-scale data-distributed machine learning and big-data related optimization, and therefore received significant amount of attention beginning in 2015. Considerable work was conducted thereafter. . On the theoretical side, ADMM was shown to have an O(1/N) rate of convergence for convex problems. . The algorithm solves the problem in the form: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minimize $f(x) + g(z)$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subject to $Ax+ Bz = c$ . with variables $x in R^n$ and $z in R^m$, where $A in R^{pxn}$, $B in R^{pxm}$ and $C in R^{p}$. . The only difference from the general linear equality-constrained problem is that the variable x has been split into two parts, called x and z, with the objective function separable across this splitting. The optimal value of the problem is now denoted by: $$ p^* = inf left { f(x) + g(x) | Ax + Bz = c right } $$ Which forms the augmented Lagrangian: $$ L_p(x, z, y) = f(x) + g(z) + y^T(Ax+Bz-c) + frac{ rho}{2} left | Ax + Bz -c right |_{2}^{2} $$ . Finally, we have our ADMM which consists of the following iterations: $$ x^{k+1} = underset{x}{argmin} L_ rho(x, z^k, y^k)$$ $$ z^{k+1} = underset{x}{argmin} L_ rho(x^{k+1}, z, y^k) $$ $$ y^{k+1} = y^k + rho(Ax^{k+1} +Bz^{k+1}-c) $$ $$s.t. rho&gt;0$$ . The algorithm is very similar to dual ascent and the method of multipliers: it consists of an x-minimization step, a z-minimization step, and a dual variable update. As in the method of multipliers, the dual variable update uses a step size equal to the augmented Lagrangian parameter. However, while with the method of multipliers the augmented Lagrangian is minimized jointly with respect to the two primal variables, in ADMM, on the other hand, x and z are updated in an alternating or sequential fashion, which accounts for the term alternating direction. . Simple examples show that ADMM can be very slow to converge to high accuracy. However, it is often the case that ADMM converges to modest accuracy—sufficient for many applications—within a few tens of iterations. This behavior makes ADMM similar to algorithms likethe conjugate gradient method, for example, in that a few tens of iterations will often produce acceptable results of practical use. However, the slow convergence of ADMM also distinguishes it from algorithms such as Newton’s method (or, for constrained problems, interior-point methods), where high accuracy can be attained in a reasonable amount of time. While in some cases it is possible to combine ADMM with a method for producing a high accuracy solution from a low accuracy solution, in the general case ADMM will be practically useful mostly in cases when modest accuracy is sufficient. Fortunately, this is usually the case for large-scale industrial applications. Also, in the case of machine learning problems, solving a parameter estimation problem to very high accuracy often yields little to no improvement in actual prediction performance, the real metric of interest in applications. . Our Optimization Problem . First we will write the augmented Lagrangian function (the scaled form) and drive the ADMM updates. . Scaled form of the augmented Lagrangian . $$ L(x, z, u: rho) = min frac{1}{2} left | Ax-b right |_{2}^{2} + lambda_{1} left | z right |_{1} + frac{ lambda_{2}}{2} left | z right |_{2}^{2} + frac{ rho}{2} left | x-z+ w right |_{2}^{2} + frac{ rho}{2} left | w right |_{2}^{2} $$ . $$ x_{k} = underset{x}{argmin} frac{1}{2} left | Ax-b right |_{2}^{2} + frac{ rho}{2} left | x-z_{k-1}+ w_{k-1} right |_{2}^{2} $$ . $$ x_k = ((A^TA+ rho I))^{-1}( rho(z_{k-1}-w_{k-1})+A^Tb) $$ . $$ z_{k} = underset{z}{argmin} ( lambda_{1} left | z right |_{1} + frac{ lambda_{2}}{2} left | z right |_{2}^{2}) + frac{ rho}{2} left | x_{k}-z+ w_{k-1} right |_{2}^{2} $$ . if $z&gt;0$ $$ z_{k} = frac{ rho(w_{k-1}+x_{k})}{ lambda_2- rho}- lambda_1$$ . if $z&lt;0$ $$ z_{k} = frac{ rho(w_{k-1}+x_{k})}{ lambda_2- rho}+ lambda_1$$ . $$ w_{k} = w_{k-1} + x_k -z_k $$ . Practical Application . Now, we will implement a regression algorithm using our augmented lagrangian. The dataset is the performance decay over time of a ship&#39;s Gas Turbine (GT) compressor. We split our test and train data 20:80. The range of decay of compressor has been sampled with a uniform grid of precision 0.001 so to have a good granularity of representation. For the compressor decay state discretization the kMc coefficient has been investigated in the domain [0.95,1]. Ship speed has been investigated sampling the range of feasible speed from 3 knots to 27 knots with a granularity of representation equal to tree knots. A series of measures (13 features) which indirectly represents of the state of the system subject to performance decay has been acquired and stored in the dataset over the parameter’s space. . The A 13-feature vector containing the GT measures at steady state of the physical asset: . Lever position (lp) | Ship speed (v) | Gas Turbine (GT) shaft torque (GTT) | GT rate of revolutions (GTn) | Gas Generator rate of revolutions (GGn) | Port Propeller Torque (Tp) | Hight Pressure (HP) Turbine exit temperature (T48) | GT Compressor outlet air temperature (T2) | HP Turbine exit pressure (P48) | GT Compressor outlet air pressure (P2) | GT exhaust gas pressure (Pexh) | Turbine Injection Control (TIC) | Fuel flow (mf) | GT Compressor decay state coefficient | . import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline from scipy.io import loadmat . ship_test = pd.read_csv(&quot;Shiptest-2.csv&quot;, header=None) ship_train = pd.read_csv(&quot;Shiptrain-2.csv&quot;, header=None) . X_train = ship_train.iloc[:,:-1] y_train = ship_train.iloc[:,-1:] X_test = ship_test.iloc[:,:-1] y_test = ship_test.iloc[:,-1:] . lambda_1 = 0.1 lambda_2 = 0.9 . iterations = 100 rho = 0.1 w = 0 z = np.random.rand(13).reshape(-1,1) A = X_train.values b = y_train.values loss = [] for i in range(iterations): x = (np.linalg.inv(np.dot(A.T,A) + (rho*np.eye(13)))).dot(rho*(z-w) + np.dot(A.T, b)) for i in range(len(z)): if np.sign(z[i])&gt;0: z = rho*(w+x)/(lambda_2-rho) - lambda_1 else: z = rho*(w+x)/(lambda_2-rho) + lambda_1 w = w + rho*(x-z) loss.append(np.sum(0.5*(np.dot(A,x)-b)**2)) . plt.figure(figsize=(10,5)) plt.plot(loss) plt.title(&#39;Obj function vs iterations&#39;) plt.xlabel(&#39;Number of iterations&#39;) plt.ylabel(&#39;Obj&#39;) . Text(0, 0.5, &#39;Obj&#39;) . print(&quot;Coefficients&quot;) x . Coefficients . array([[-5.05840315e-02], [ 1.03456745e-02], [ 1.21482112e-05], [-2.86479882e-04], [-1.49933306e-05], [-1.52302544e-03], [-9.13559793e-04], [ 1.36474482e-03], [ 1.85080531e-01], [ 5.00636758e-02], [ 6.72727845e-01], [-1.62063399e-04], [-1.76737055e-01]]) . Sum absolute errors . abs_ms_errors = [] abs_errors = [] for A, b in zip(X_test.values, y_test.values): abs_ms_errors.append(abs(np.sum(0.5*(np.dot(A,x)-b)**2))) abs_errors.append(abs(np.sum(np.dot(A,x)-b))) print(&quot;Sum absolute mean-squared errors:&quot;, round(sum(abs_ms_errors), 2)) print(&quot;Sum absolute errors:&quot;, round(sum(abs_errors), 2)) . Sum absolute mean-squared errors: 0.14 Sum absolute errors: 21.1 .",
            "url": "https://jackhmiller.github.io/My-DS-Blog/2020/04/20/ADMM.html",
            "relUrl": "/2020/04/20/ADMM.html",
            "date": " • Apr 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://jackhmiller.github.io/My-DS-Blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  
    
  

  
  

  
      ,"page1": {
          "title": "My CV",
          "content": "Work Experience . Data Scientist at Sparks AB . Hod Hasharon, October 2019 – Current . ML &amp; Deep Learning for Algorithmic Trading | End-to-end data science pipelines for financial market predictions, including research, feature creation/selection, model training/optimization, and deployment architecture | Deep learning (RNN, CNN, transformers) &amp; machine learning models (gradient boosting) | Engineering using AWS Cloud suite, Jenkins, custom APIs to automate training and deployment | . Junior Data Scientist/ML Engineer at WeWork Technology . Tel Aviv, November January 2019 – October 2019 . Data Science &amp; Engineering | Automated end-to-end data pipeline engineering using AWS, Snowflake &amp; Apache Airflow | Reproducible DS environment engineering using Docker and Jupyter | Unstructured sentiment modeling and automation for global billing and payment services | Anomaly detection model for payment API monitoring &amp; security | . Senior Data Analyst at EY (Ernst &amp; Young) . Tel Aviv, November 2016 – December 2018 . Innovation and R&amp;D | Machine &amp; deep learning PoCs for Israeli and international consulting clients as solutions to predictive and analytics challenges | Sample of projects: financial anomaly detection for global bank, unsupervised learning model for drug discovery for pharma co., appraisal modeling for commercial real estate | . (Aliyah and army service October 2015 – November 2016) . Quant Analyst at McKinsey &amp; Co. . Washington D.C., January 2013-October 2015 . Quantitative Analytics and Modeling | Modeling for warfare simulations and predictions regarding autonomous robotics | Part of DoD-led study to determine the effectiveness of commercial &amp; defense machine learning technologies to solve defense needs | . Research Associate at Defense Advanced Research Projects Agency (DARPA) . Philadelphia, PA, September 2011- May 2014 . Competitive contingency estimation program | Heuristic modeling for event forecasting and classification | Sentiment analysis research for modeling of exogenous events &amp; systematic shocks | . Education . University of Pennsylvania, BA Statistics | 2010-2014 . Military Applications of Statistical Modeling | GPA: 3.9/4.0 Magna Cum Laude | . Georgia Tech, Msc Computer Science | 2020-Present . Computational Perception and Robotics | GPA: 3.8/4.0 | .",
          "url": "https://jackhmiller.github.io/My-DS-Blog/CV/",
          "relUrl": "/CV/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "About Me",
          "content": "I am a data scientist working and based in Israel, with an undergraduate degree in statistics from the University of Pennsylvania, and a masters degree in computer science Georgia Tech. . 050-709-2944 | Jack.harris.miller@gmail.com . .",
          "url": "https://jackhmiller.github.io/My-DS-Blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jackhmiller.github.io/My-DS-Blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}